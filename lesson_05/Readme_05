Задание 1.
Вспомнить, как делать генераторы, было быстро. Но возник вопрос: как его вернуть из функции целиком,
а не по элементам, с помощью yield. Прочитал конспект, презентацию и методичку, там такого нет. Наоборот
говорится, что из функции генератор будет выдавать первое значение, если не использовать yield.
Прочитал зеленую и жёлтую подсказки, там сказано, что в методичке это есть. Перечитал ещё раз методичку -
снова не нашёл. Потратил на это всё около часа и пошел в чат за Вашим советом.
Там посоветовали присвоить значение функции переменной (не думал, что так можно) - и всё заработало.

* Усложненный вариант заработал сразу, но выводил какую-то белиберду:
n: 20
3
Traceback (most recent call last):
  File "E:\Обучение программированию\Python\PYTHON\Practice\python_learning\lesson_05\task_05_01_var_2.py", line 15, in <module>
    print(next(gen))
StopIteration
7
11

Причём каждый раз разную. Перепроверил в консоли - всё работает правильно. Решил перезапустить пайчарм.
Нашёл, что через одно значение печаталось из-за того, что для проверки работы сам добавил print(next(gen)).
Исправил - всё заработало правильно, но так же криво (сообщение о StopIteration появлялось рандомно
между любыми напечатанными значениями генератора). Почему так происходит - непонятно.
Но генератор истощается)


Задание 2.
Базовое сделать было легко. Немного повозился с синтаксисом и всё.

Задание с одной звёздочкой по логике тоже было понятно, но синтаксис yield (gen_step if gen_step ** 2 < 200)
не сработал. Вызвал ошибку SyntaxError: expected 'else' after 'if' expression.
Пришлось придумать, как написать по-другому.

Задание с двумя точками не понял, где мы должны посчитать сумму, решил и так, что сами считаем, и так,
что считает функция.
Немного пришлось пробираться через ошибки, вызванные синтаксисом, но всё не так уж страшно.


Задание 3.
Почему-то строка tuple_gen = (tutor for tutor in tutors, (group for group in groups if group else None)
вызвала ошибку SyntaxError: invalid syntax

Тогда решил пойти через функцию. Вариант, где учеников меньше, чем классов, решил достаточно быстро. А
вот с None возникли трудности.

def tuple_gen(tutors, groups):
    for tutor in tutors:
        if groups[tutors.index(tutor)]:
            yield (tutor, groups[tutors.index(tutor)])
        else:
            yield (tutor, None)

вместо того, чтобы добавлять None вызывал ошибку list index out of range.
Изменил на:

def tuple_gen(tutors, groups):
    for tutor in tutors:
        pair = ()
        if groups[tutors.index(tutor)]: # тут заметил ошибку. Если Иванов будет 2, венётся индекс первого.
            pair = (tutor, groups[tutors.index(tutor)])
        else:
            pair = (tutor, None)
        yield pair

Ошибка исчезла, но кортежи формировались только для тех пар, где хватало классов. Пары с None не получались.
Подсказки не помогли (прочёл и зеленую, и желтую), они описали именно то, что я пытался сделать.
В итоге, перебрав несколько вариантов, дошел до того, который сработал. Но в чём ошибкаа - так и не понял.
Буду благодарен, если объясните. В файле это строки 65-93.
Переписывать функцию в строку уже не было ни сил, ни времени, ни желания (

Задание 4.
Минут за 5-10 собрал строку, ошибка была только в том, что сначала хотел i прогнать по len(src)-1.
Пришлось добавить range, т.к. len - просто число.
Как в эту строку добавить сравнение первого с последним быстро придумать не получилось.
Пока думал над пятым, понял, что сравнить первое с последним даже проще, чем не сравнивать)))

Задание 5.
После 4-го задания на это ушло минут 10.
Помню, что на предварительных курсах в соученики выкладывали list.count() в решениях, и Вы в чате разрешили
его использовать.
