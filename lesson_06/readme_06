Задание 1.
Пошаговый алгоритм решения вопросов не вызвал вообще. Сложности возникли на первом же шаге реализации:
ни в методичке, ни в презентации, ни в конспекте к уроку не было написано примеров, подобных тому, что
рассматривали на уроке (как прописать путь к файлу в другой папке). Чтение
https://docs.python.org/3/library/os.path.html разобраться не помогло ( Там нет примеров правильного
синтаксиса, а, видимо, именно в нём и была ошибка:
file_path = os.path.join('.', 'data_for_practice', 'nginx_logs.txt') (не работало ни с '.', ни без неё)
При этом os.path.isfile('data_for_practice/nginx_logs.txt') в консоли выдавало True.
Поэтому решил открывать файл, прямо прописывая путь к нему.
Разбить строку и вычленить нужные данные труда не составило (дольше искал урок, в котором это делали,
чтобы посмотреть синтаксис команды).
А вот на этапе вывода возникла сложность. Список выводился не по одному кортежу на строку, а друг за другом.
print(result_list, sep='\n') не сработал (видимо, потому что принт считал, что печатает один объект).
result_list.append(\n) и result_list.append('\n') тоже не сработали.
Заглянул в подсказки (и желтую, и зеленую) - там было описано то, что уже сделано...
Нагуглить где-то за час тоже не вышло. Поэтому задал вопрос в чат и отложил решение задачи до получения подсказки.
Решил на следующий день, получив подсказку распаковать список)

Задание 3.
Сначала была небольшая организационная непонятка с пайчармом (что не поддерживает .csv), но это ерунда.
Алгоритм целиком сразу даже не продумывал, решил решать по кусочкам.
Открыть файлы и достать строки - без проблем. А вот обрезать фамилию, имя и отчество и получить строку ФИО
получилось не сразу.
fio = ()
for name in fio_full:
    fio += (name[:1])
вызывало ошибку TypeError: can only concatenate tuple (not "str") to tuple
Только подглянув на pythonworld догадался, что вместо () надо ''.
В итоге на одной строке всё получилось, а вот с циклом возникли сложности.
 while users:
     while hobbyes:
         if users and hobbyes:
             fio_full = users.readline().split(',')
             fio = ''
             for name in fio_full:
                 fio += (name[:1])
             hobby = hobbyes.readline().strip('\n').replace(',', ';')
             res_dict = {fio: hobby} # или res_dict[fio] = hobby
не хотел работать. Точнее, работал бесконечно. В чём загвоздка, не знаю как найти, поэтому решил всё переписать
по-другому, работая со списками (хоть и интересно было бы понять, как сделать это через циклы, чтобы можно было
работать с большими файлами).
На следующий день понял что цикл в цикле - вообще неправильная идея. Нам же не нужно для каждой итерации внешнего
прогонять весь внутренний, и тут лучше подошел бы цикл с индексом по длине списка ФИО.

Но я уже переписал код на работу со списками, полученными через .readlines, и не хотел возвращаться назад.
В списках вылезла маленькая сложность с \n в конце строки.
.replace её не видел, циклом поменять строки внутри списка тоже не получилось, пришлось создать новый список для
хобби без \n:
hobbyes_list_without_n = []
for hobby in hobbyes_list:
    hobby = hobby.strip('\n')
    hobbyes_list_without_n.append(hobby)

А потом сделал всё в одну строку через .read().splitline()
Дальше кучу времени убил на то, чтобы найти в методичке, что такое "выйти из скрипта с кодом 1" )))
После Вашей подсказки про 4-ый урок остально было делом техники. Условие - цикл.
Сначала не получилось записать словарь в текстовый файл, для метода .write нужна была строка. Записал сразу
файл .json. Благодаря обсуждению в чате получилсь быстро найти про ensure_ascii=False. А уже после этого
просто дописал перевод словаря в строку и запись этой строки в текстовый файл.

Непонятным остался момент, влияет ли в таком случае на что-то то, что при открытии файла мы пишем
encoding='utf-8', ведь без ensure_ascii данные записываются в нечитаемом виде.
По ходу решения заглядывал и в зеленую, и в желтую подсказки, но они были бесполезны.

Задание 4.
В самом начале был страх. Не умею работать из косоли. Но помогла открытая для прошлого задания методичка_4.
Там попался код с argv. До сих пор не понимаю до конца argv, *args и **kwargs, но глядя на примеры что-то получается.
написал код для записи, но он упорно не хотел выдавать для записи число, а выдавал или [], или ['1500']. Избавиться
от лишних символов получилось благодаря распаковке через *. Получилось не сразу, понимания синтаксиса этой штуки нет,
но методом научного тыка подобрал звёздочке нужное место.
Потом стал обрабатывать исключения - тут помог материал подготовительного курса, хоть и не сразу, но получилось.

С файлом-считывателем сразу стало непонятно, как читать отдельные строки.
После Вашей подсказки решил считывать через цикл, печатая нужные строки.
Далее затык произошел с передачей данных скрипту. То ли пайчарм глючил, то ли я что-то делал не так (
Всё время вылезала ошибка [Errno 2] No such file or directory.
Как-то её поборол (не совсем понял, как) и дальше оставалось только разобраться с форматом argv.
Когда разобрался - написать ифы и циклы было делом техники.




